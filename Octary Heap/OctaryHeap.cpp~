/*-- OctaryHeap.cpp --*/

#include <iostream>
#include <vector>
#include "OctaryHeap.h"

using namespace std;

Node::Node () : id(0), key(infinite) {}
Node::~Node () {}

//private methods

bool OctaryHeap::root (unsigned long p) { return (p == 0); }

unsigned int OctaryHeap::key (unsigned long p) { return v[p]; }
unsigned long OctaryHeap::parent (unsigned long p) { return ((p - 1) / 8); }
unsigned long OctaryHeap::child (unsigned long p, unsigned long c) { return ((8 * p) + c ); }

unsigned long OctaryHeap::num_child (unsigned long p) {
  unsigned long k = 1;
  if ((child(p,k)) >= length)
    return (0);
  while (child(p,++k) < length) //start with k == 2
    if (k > 8) return (8);
  return (k-1);
}

int OctaryHeap::heapify_up (unsigned long p) {

	if (root(p)) return 0;

	if (key(parent(p)) > key(p)) {
		swap (pos[key(p)], pos[key(parent(p))]);
		swap (v[parent(p)], v[p]);
		heapify_up (parent(p));
	}

		return 0;
}

int OctaryHeap::heapify_down (unsigned long p) {

  if (num_child(p) == 0)
    return (0);

  if (num_child(p) == 1)
    if (key(child(p,1)) < key(p)) {
      swap (pos[key(p)], pos[key(child(p,1))]);
      swap (v[child(p,1)], v[p]);
    }

  return (0);

  unsigned long m = child(p,2);

  for (unsigned long k = 3; i <= 8; i++) {
    if ((key(child(p,k))) < key(m))
      m = child(p,k);
  }

  if (key(m) < key(p)) {
      swap (pos[key(p)], pos[key(m)]);
      swap (v[m], v[p]);
  }

  if (num_child(p) == 8)
    heapify_down(m);

  return 0;
    
}

OctaryHeap::OctaryHeap (unsigned long par) : v(par), pos(par) {  //StartHeap-like constructor

	length = 0;

}

OctaryHeap::~OctaryHeap () {} //class destructor

unsigned long OctaryHeap::get_pos (unsigned long c) { return pos[c]; }

bool OctaryHeap::empty () { return length == 0? true : false; }

void OctaryHeap::insert (unsigned int d) {

  v[length] = d;
  pos[d] = length;
  length++;
  heapify_up (length - 1);

}

void OctaryHeap::Delete (unsigned long p) {

  --length;

  swap (pos[key(p)], pos[key(length)]);
  swap (v[p], v[length]);


  v[length+1] = infinite;

  heapify_down (p);

}

unsigned int OctaryHeap::get_min () {
		return (v[0]);
 }

unsigned int OctaryHeap::delete_min () {
		unsigned int res = v[0]
		Delete (0);
		return (res);
}

void OctaryHeap::update (unsigned long p, unsigned int x) {

	if (x < key(p)) {
		v[p] = x;
		heapify_up(p);
	}
	else {
		v[p] = x;
		heapify_down(p);
	}

}
